"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[231],{4231:(e,t,n)=>{async function a(e,t,n,a){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},{chunkSize:c=0x1400000,onProgress:r}=o,s=Math.ceil(t.size/c);if(!e)throw Error("Supabase client is required");try{let o=a.substring(0,a.lastIndexOf("/"))||"",l=a.substring(a.lastIndexOf("/")+1),i=t.name||l.replace(/^\d+-/,""),u=i.replace(/\.[^/.]+$/,""),h=i.match(/\.[^/.]+$/)?i.match(/\.[^/.]+$/)[0]:"",d=u.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),f=h.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");console.log('Checking for existing chunks. Original filename: "'.concat(i,'", Base filename: "').concat(l,'"'));let p=new Set,g=null;try{let{data:t}=await e.storage.from(n).list(o);if(t&&t.length>0){let e=new RegExp("^".concat(l.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"\\.chunk\\.\\d+$")),n=t.filter(t=>e.test(t.name));if(0===n.length){let e=new RegExp("^\\d+-".concat(d).concat(f,"\\.chunk\\.\\d+$"));if((n=t.filter(t=>{let n=e.test(t.name);return n&&console.log("Found matching chunk: ".concat(t.name)),n})).length>0){console.log("Found ".concat(n.length,' chunks from a previous upload of the same file: "').concat(i,'". Using existing chunks.')),g=e;let t=n[0].name.replace(/\.chunk\.\d+$/,"");console.log("Previous upload detected. Base path: ".concat(t))}else console.log("No existing chunks found for pattern: ^\\d+-".concat(d).concat(f,"\\.chunk\\.\\d+$"))}else g=e;n.forEach(e=>{let t=e.name.match(/\.chunk\.(\d+)$/);t&&p.add(parseInt(t[1]))})}}catch(e){console.warn("Could not check for existing chunks:",e.message)}if(p.size>0&&(console.log("Found ".concat(p.size," existing chunks. Will skip those and upload ").concat(s-p.size," missing chunks.")),g&&p.size>=.9*s))return console.log("File appears to be already uploaded (".concat(p.size,"/").concat(s," chunks exist).")),{success:!0,alreadyUploaded:!0,existingChunks:p.size};for(let o=0;o<s;o++){if(p.has(o)||p.has(o)){if(r){let e=(o+1)*c;r({chunkNumber:o+1,totalChunks:s,bytesUploaded:Math.min(e,t.size),totalBytes:t.size,percentage:Math.round(Math.min(e,t.size)/t.size*100),skipped:!0})}continue}let l=o*c,i=Math.min(l+c,t.size),u=t.slice(l,i),h="".concat(a,".chunk.").concat(o),d=3;for(;d>0;)try{let{error:t}=await e.storage.from(n).upload(h,u,{cacheControl:"3600",upsert:!0});if(t){if(--d>0){let e=1e3*Math.pow(2,3-d);console.warn("Chunk ".concat(o+1," upload failed, retrying in ").concat(e,"ms... (").concat(d," retries left)")),await new Promise(t=>setTimeout(t,e));continue}throw Error("Failed to upload chunk ".concat(o+1,"/").concat(s," after 3 attempts: ").concat(t.message))}break}catch(t){if(d--,0===d)throw Error("Failed to upload chunk ".concat(o+1,"/").concat(s,": ").concat(t.message));let e=1e3*Math.pow(2,3-d);console.warn("Chunk ".concat(o+1," upload error, retrying in ").concat(e,"ms... (").concat(d," retries left)")),await new Promise(t=>setTimeout(t,e))}r&&r({chunkNumber:o+1,totalChunks:s,bytesUploaded:i,totalBytes:t.size,percentage:Math.round(i/t.size*100)}),o<s-1&&await new Promise(e=>setTimeout(e,100))}return{success:!0}}catch(e){return console.error("Chunked upload error:",e),{success:!1,error:e.message||"Upload failed"}}}async function o(e,t,n,a){let o=[];for(let c=0;c<a;c++){let a="".concat(n,".chunk.").concat(c),{data:r,error:s}=await e.storage.from(t).download(a);if(s)throw Error("Failed to download chunk ".concat(c,": ").concat(s.message));o.push(await r.arrayBuffer())}let c=new Uint8Array(o.reduce((e,t)=>e+t.byteLength,0)),r=0;for(let e of o)c.set(new Uint8Array(e),r),r+=e.byteLength;return new Blob([c])}async function c(e,t,n,a){let o=[];for(let e=0;e<a;e++)o.push("".concat(n,".chunk.").concat(e));try{await e.storage.from(t).remove(o)}catch(e){console.warn("Failed to cleanup chunks:",e)}}n.r(t),n.d(t,{cleanupChunks:()=>c,downloadAndReassembleChunks:()=>o,uploadFileInChunks:()=>a})}}]);