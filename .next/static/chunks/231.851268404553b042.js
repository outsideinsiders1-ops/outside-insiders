"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[231],{4231:(e,t,a)=>{async function n(e,t,a,n){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},{chunkSize:r=0x1400000,onProgress:c}=o,s=Math.ceil(t.size/r);if(!e)throw Error("Supabase client is required");try{let o=n.substring(0,n.lastIndexOf("/"))||"",i=n.substring(n.lastIndexOf("/")+1),l=new Set;try{let{data:t}=await e.storage.from(a).list(o);if(t){let e=new RegExp("^".concat(i.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"\\.chunk\\.\\d+$"));t.forEach(t=>{let a=t.name.match(/\.chunk\.(\d+)$/);a&&e.test(t.name)&&l.add(parseInt(a[1]))})}}catch(e){console.warn("Could not check for existing chunks:",e.message)}l.size>0&&console.log("Found ".concat(l.size," existing chunks. Will skip those and upload ").concat(s-l.size," missing chunks."));for(let o=0;o<s;o++){if(l.has(o)){if(c){let e=(o+1)*r;c({chunkNumber:o+1,totalChunks:s,bytesUploaded:Math.min(e,t.size),totalBytes:t.size,percentage:Math.round(Math.min(e,t.size)/t.size*100),skipped:!0})}continue}let i=o*r,u=Math.min(i+r,t.size),h=t.slice(i,u),d="".concat(n,".chunk.").concat(o),f=3;for(;f>0;)try{let{error:t}=await e.storage.from(a).upload(d,h,{cacheControl:"3600",upsert:!0});if(t){if(--f>0){let e=1e3*Math.pow(2,3-f);console.warn("Chunk ".concat(o+1," upload failed, retrying in ").concat(e,"ms... (").concat(f," retries left)")),await new Promise(t=>setTimeout(t,e));continue}throw Error("Failed to upload chunk ".concat(o+1,"/").concat(s," after 3 attempts: ").concat(t.message))}break}catch(t){if(f--,0===f)throw Error("Failed to upload chunk ".concat(o+1,"/").concat(s,": ").concat(t.message));let e=1e3*Math.pow(2,3-f);console.warn("Chunk ".concat(o+1," upload error, retrying in ").concat(e,"ms... (").concat(f," retries left)")),await new Promise(t=>setTimeout(t,e))}c&&c({chunkNumber:o+1,totalChunks:s,bytesUploaded:u,totalBytes:t.size,percentage:Math.round(u/t.size*100)}),o<s-1&&await new Promise(e=>setTimeout(e,100))}return{success:!0}}catch(e){return console.error("Chunked upload error:",e),{success:!1,error:e.message||"Upload failed"}}}async function o(e,t,a,n){let o=[];for(let r=0;r<n;r++){let n="".concat(a,".chunk.").concat(r),{data:c,error:s}=await e.storage.from(t).download(n);if(s)throw Error("Failed to download chunk ".concat(r,": ").concat(s.message));o.push(await c.arrayBuffer())}let r=new Uint8Array(o.reduce((e,t)=>e+t.byteLength,0)),c=0;for(let e of o)r.set(new Uint8Array(e),c),c+=e.byteLength;return new Blob([r])}async function r(e,t,a,n){let o=[];for(let e=0;e<n;e++)o.push("".concat(a,".chunk.").concat(e));try{await e.storage.from(t).remove(o)}catch(e){console.warn("Failed to cleanup chunks:",e)}}a.r(t),a.d(t,{cleanupChunks:()=>r,downloadAndReassembleChunks:()=>o,uploadFileInChunks:()=>n})}}]);