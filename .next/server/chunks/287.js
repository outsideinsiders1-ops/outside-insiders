"use strict";exports.id=287,exports.ids=[287],exports.modules={6287:(a,b,c)=>{async function d(a,b,c,e,f={}){let{chunkSize:g=0x1400000,onProgress:h}=f,i=Math.ceil(b.size/g);if(!a)throw Error("Supabase client is required");try{let d=e.substring(0,e.lastIndexOf("/"))||"",f=e.substring(e.lastIndexOf("/")+1),j=new Set;try{let{data:b}=await a.storage.from(c).list(d);if(b){let a=RegExp(`^${f.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\.chunk\\.\\d+$`);b.forEach(b=>{let c=b.name.match(/\.chunk\.(\d+)$/);c&&a.test(b.name)&&j.add(parseInt(c[1]))})}}catch(a){console.warn("Could not check for existing chunks:",a.message)}j.size>0&&console.log(`Found ${j.size} existing chunks. Will skip those and upload ${i-j.size} missing chunks.`);for(let d=0;d<i;d++){if(j.has(d)){if(h){let a=(d+1)*g;h({chunkNumber:d+1,totalChunks:i,bytesUploaded:Math.min(a,b.size),totalBytes:b.size,percentage:Math.round(Math.min(a,b.size)/b.size*100),skipped:!0})}continue}let f=d*g,k=Math.min(f+g,b.size),l=b.slice(f,k),m=`${e}.chunk.${d}`,n=3;for(;n>0;)try{let{error:b}=await a.storage.from(c).upload(m,l,{cacheControl:"3600",upsert:!0});if(b){if(--n>0){let a=1e3*Math.pow(2,3-n);console.warn(`Chunk ${d+1} upload failed, retrying in ${a}ms... (${n} retries left)`),await new Promise(b=>setTimeout(b,a));continue}throw Error(`Failed to upload chunk ${d+1}/${i} after 3 attempts: ${b.message}`)}break}catch(b){if(n--,0===n)throw Error(`Failed to upload chunk ${d+1}/${i}: ${b.message}`);let a=1e3*Math.pow(2,3-n);console.warn(`Chunk ${d+1} upload error, retrying in ${a}ms... (${n} retries left)`),await new Promise(b=>setTimeout(b,a))}h&&h({chunkNumber:d+1,totalChunks:i,bytesUploaded:k,totalBytes:b.size,percentage:Math.round(k/b.size*100)}),d<i-1&&await new Promise(a=>setTimeout(a,100))}return{success:!0}}catch(a){return console.error("Chunked upload error:",a),{success:!1,error:a.message||"Upload failed"}}}async function e(a,b,c,d){let e=[];for(let f=0;f<d;f++){let d=`${c}.chunk.${f}`,{data:g,error:h}=await a.storage.from(b).download(d);if(h)throw Error(`Failed to download chunk ${f}: ${h.message}`);e.push(await g.arrayBuffer())}let f=new Uint8Array(e.reduce((a,b)=>a+b.byteLength,0)),g=0;for(let a of e)f.set(new Uint8Array(a),g),g+=a.byteLength;return new Blob([f])}async function f(a,b,c,d){let e=[];for(let a=0;a<d;a++)e.push(`${c}.chunk.${a}`);try{await a.storage.from(b).remove(e)}catch(a){console.warn("Failed to cleanup chunks:",a)}}c.r(b),c.d(b,{cleanupChunks:()=>f,downloadAndReassembleChunks:()=>e,uploadFileInChunks:()=>d})}};