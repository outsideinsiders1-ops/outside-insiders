"use strict";exports.id=287,exports.ids=[287],exports.modules={96287:(a,b,c)=>{async function d(a,b,c,e,f={}){let{chunkSize:g=0x1400000,onProgress:h}=f,i=Math.ceil(b.size/g);if(!a)throw Error("Supabase client is required");try{let d=e.substring(0,e.lastIndexOf("/"))||"",f=e.substring(e.lastIndexOf("/")+1),j=b.name||f.replace(/^\d+-/,""),k=j.replace(/\.[^/.]+$/,""),l=j.match(/\.[^/.]+$/)?j.match(/\.[^/.]+$/)[0]:"",m=k.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),n=l.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");console.log(`Checking for existing chunks. Original filename: "${j}", Base filename: "${f}"`);let o=new Set,p=null;try{let{data:b}=await a.storage.from(c).list(d);if(b&&b.length>0){let a=RegExp(`^${f.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\.chunk\\.\\d+$`),c=b.filter(b=>a.test(b.name));if(0===c.length){let a=RegExp(`^\\d+-${m}${n}\\.chunk\\.\\d+$`);if((c=b.filter(b=>{let c=a.test(b.name);return c&&console.log(`Found matching chunk: ${b.name}`),c})).length>0){console.log(`Found ${c.length} chunks from a previous upload of the same file: "${j}". Using existing chunks.`),p=a;let b=c[0].name.replace(/\.chunk\.\d+$/,"");console.log(`Previous upload detected. Base path: ${b}`)}else console.log(`No existing chunks found for pattern: ^\\d+-${m}${n}\\.chunk\\.\\d+$`)}else p=a;c.forEach(a=>{let b=a.name.match(/\.chunk\.(\d+)$/);b&&o.add(parseInt(b[1]))})}}catch(a){console.warn("Could not check for existing chunks:",a.message)}if(o.size>0&&(console.log(`Found ${o.size} existing chunks. Will skip those and upload ${i-o.size} missing chunks.`),p&&o.size>=.9*i))return console.log(`File appears to be already uploaded (${o.size}/${i} chunks exist).`),{success:!0,alreadyUploaded:!0,existingChunks:o.size};for(let d=0;d<i;d++){if(o.has(d)||o.has(d)){if(h){let a=(d+1)*g;h({chunkNumber:d+1,totalChunks:i,bytesUploaded:Math.min(a,b.size),totalBytes:b.size,percentage:Math.round(Math.min(a,b.size)/b.size*100),skipped:!0})}continue}let f=d*g,j=Math.min(f+g,b.size),k=b.slice(f,j),l=`${e}.chunk.${d}`,m=3;for(;m>0;)try{let{error:b}=await a.storage.from(c).upload(l,k,{cacheControl:"3600",upsert:!0});if(b){if(--m>0){let a=1e3*Math.pow(2,3-m);console.warn(`Chunk ${d+1} upload failed, retrying in ${a}ms... (${m} retries left)`),await new Promise(b=>setTimeout(b,a));continue}throw Error(`Failed to upload chunk ${d+1}/${i} after 3 attempts: ${b.message}`)}break}catch(b){if(m--,0===m)throw Error(`Failed to upload chunk ${d+1}/${i}: ${b.message}`);let a=1e3*Math.pow(2,3-m);console.warn(`Chunk ${d+1} upload error, retrying in ${a}ms... (${m} retries left)`),await new Promise(b=>setTimeout(b,a))}h&&h({chunkNumber:d+1,totalChunks:i,bytesUploaded:j,totalBytes:b.size,percentage:Math.round(j/b.size*100)}),d<i-1&&await new Promise(a=>setTimeout(a,100))}return{success:!0}}catch(a){return console.error("Chunked upload error:",a),{success:!1,error:a.message||"Upload failed"}}}async function e(a,b,c,d){let e=[];for(let f=0;f<d;f++){let d=`${c}.chunk.${f}`,{data:g,error:h}=await a.storage.from(b).download(d);if(h)throw Error(`Failed to download chunk ${f}: ${h.message}`);e.push(await g.arrayBuffer())}let f=new Uint8Array(e.reduce((a,b)=>a+b.byteLength,0)),g=0;for(let a of e)f.set(new Uint8Array(a),g),g+=a.byteLength;return new Blob([f])}async function f(a,b,c,d){let e=[];for(let a=0;a<d;a++)e.push(`${c}.chunk.${a}`);try{await a.storage.from(b).remove(e)}catch(a){console.warn("Failed to cleanup chunks:",a)}}c.r(b),c.d(b,{cleanupChunks:()=>f,downloadAndReassembleChunks:()=>e,uploadFileInChunks:()=>d})}};